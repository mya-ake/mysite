{"title":"Nuxt.js on AWS Lambda","description":"Vue.jsのユニバーサルアプリケーションを作るためのフレームワークであるNuxt.jsをAWS Lambdaで動かす方法について書かれている記事です。","body":"<p></p>\n<h2 id=\"この記事について\">この記事について</h2><p>この記事は<a href=\"https://qiita.com/advent-calendar/2017/vue2\">Vue.js #2 Advent Calendar 2017 - Qiita</a>の12日目の記事です。</p>\n<p>この記事では <a href=\"https://nuxtjs.org/\">Nuxt.js</a> を <a href=\"https://aws.amazon.com/jp/lambda/\">AWS Lambda</a> で動かす方法について書いています。\nNuxt.js に関する説明もありますが、全体的にサーバー構築寄りの内容になっています。<br>しかし、Node.js で AWS にデプロイまでできる <a href=\"https://serverless.com/\">Serverless Framework</a> というツールを利用していますので、AWS を使ったことがない方でも、<a href=\"https://github.com/mya-ake/nuxt-on-lambda\">サンプルコード</a>をそのまま利用することで AWS 上に環境を作れるようにしています。（AWS への登録と Credential の生成は必要ですが......）\nご興味のある方はそちらも参照してみてください。</p>\n<p>今回は上に挙げた登場人物?たちについて簡単に説明し、なぜ SSR するのか、なぜ Lambda なのかという話もして、構成や動かすための実装コードの説明していくという盛り沢山な内容になっています。</p>\n<p>※この記事ではパッケージマネージャーに <a href=\"https://yarnpkg.com/ja/\">yarn</a>を使っていますが、\nnpmでも問題はないはずです。（すいません、npmは試してないです。</p>\n<h3 id=\"対象読者\">対象読者</h3><ul>\n<li>Vue.js のSSR（サーバーサイドレンダリング）に興味がある方</li>\n<li>Nuxt.js をどういうサーバーで稼働させようか考えている方</li>\n<li>AWS Lambdaでやろうとして上手くいかなかった方</li>\n</ul>\n<h3 id=\"登場人物?たち\">登場人物?たち</h3><ul>\n<li>Nuxt.js</li>\n<li>AWS Lambda</li>\n<li>Serverless Framework</li>\n</ul>\n<h3 id=\"アウトライン\">アウトライン</h3><ul>\n<li><a href=\"#Nuxt.js\">Nuxt.js</a></li>\n<li><a href=\"#AWS_Lambda\">AWS Lambda</a></li>\n<li><a href=\"#Serverless_Framework\">Serverless Framework</a></li>\n<li><a href=\"#なぜSSR？なぜLambda？\">なぜSSR？なぜLambda？</a></li>\n<li><a href=\"#サーバー構成\">サーバー構成</a></li>\n<li><a href=\"#実装コードの説明\">実装コードの説明</a></li>\n<li><a href=\"#まとめ\">まとめ</a></li>\n<li><a href=\"#参考記事集\">参考記事集</a></li>\n</ul>\n<h2 id=\"Nuxt.js\">Nuxt.js</h2><p>Nuxt.js は 冒頭でも書いたとおり Vue.js のユニバーサルアプリケーションを作ることができるフレームワークです。\n2017年12月12日現在はまだバージョン1がリリースされていませんが、現時点でも十分に扱える状態にあると思います。\n筆者自信もプロダクション環境で稼働させる準備を進めています。</p>\n<p>その Nuxt.js の特徴を挙げると下記のような感じです。</p>\n<ul>\n<li>SSRサポート</li>\n<li>整った開発環境<ul>\n<li>Babel</li>\n<li>ローカルサーバー（ホットリロード有り）</li>\n</ul>\n</li>\n<li>静的サイトジェネレーター</li>\n</ul>\n<p>とりあえずすごく便利です。\n開発を始めるまでのハードルがすごく低くなっています。\nまた、公式が用意している<a href=\"https://github.com/nuxt-community/starter-template\">スターターテンプレート</a>を使うことで ESLint の設定まで含まれた状態で始めることもできます。</p>\n<p>このサイト自体も Nuxt.js を利用して制作しています。\nまだ開発途中で前に作ったサイトと同居状態なのですが、Nuxt.js の静的サイトジェネレーターの機能を使い、このページだけ独立したHTMLとして出力させてサーバーに置いています。</p>\n<p>今回の主題は Nuxt.js ではないので紹介はこの程度に留めます。\nNuxt.js についてさらに知りたい方は <a href=\"https://twitter.com/potato4d\">potato4d</a>さんの<a href=\"https://html5experts.jp/potato4d/24346/\">Vue.js製フレームワークNuxt.jsではじめるUniversalアプリケーション開発 | HTML5Experts.jp</a>に詳しく書かれているので、そちらをご参照いただくことをオススメします。</p>\n<h2 id=\"AWS_Lambda\">AWS Lambda</h2><p>AWS Lambda はサーバーレスと言われる分野で使われている代表的なサービスです。\n使った分だけ課金される AWS のコンピューティングサービスです。FaaS (Function as a Service) とも呼ばれたりします。\nコードをアップするだけで稼働し、スケーリングも自動で行われるので、サーバーの管理を煩わしく思うような人におすすめです。</p>\n<p>Node.js や Python、Java など様々な ランタイムがあり、自分のやりやすい言語を選択して利用できます。最近ラスベガスで行われた AWS re:Invent 2017 では、Go言語 と .NET Core が使えるようになると発表があり、今後も使える言語は増えることが予想されます。<br>今回は Nuxt.js を動かしたいのでランタイムは Node.js を使います。</p>\n<h2 id=\"Serverless_Framework\">Serverless Framework</h2><p>Serverless Framework は AWS Lambda へのデプロイを手軽に行えるようにしてくれるツールです。\nNode.js の環境があれば動くので、Nuxt.js を使う環境であればすぐに導入できると思います。\nまた、コードベースで設定を管理できるので、同じ環境を作るのも手軽にできます。\n今回の設定などは <a href=\"https://github.com/mya-ake/nuxt-on-lambda\">GitHub</a>に置いているので、ほぼそのまま使うことができると思います。</p>\n<h2 id=\"なぜSSR？なぜLambda？\">なぜSSR？なぜLambda？</h2><p>なぜSSRするか、なぜLambdaを使うかという話は、<a href=\"https://serverless.connpass.com/event/62473/\">Serverless Meetup Fukuoka #1</a>というイベントで<a href=\"https://mya-ake.com/slides/vuejs-ssr-on-lambda\">AWS LambdaでSSRやってみた Vue.js編</a>というLTをしてきたので、そちらをご覧いただけると幸いです。</p>\n<p>ざっくりなぜSSRするかをまとめると</p>\n<ul>\n<li>Googlebotに正しくサイトを認識してもらうため</li>\n<li>ファーストビューの速度改善</li>\n<li>OGPへの対応</li>\n</ul>\n<p>ざっくりなぜLambdaを使うかをまとめると</p>\n<ul>\n<li>1リクエストで1Lambdaが動くので、突発的なアクセスなどに強い</li>\n<li>サーバーの管理をあまりしたくない</li>\n<li>安い</li>\n</ul>\n<p>以上のような理由です。\n筆者の場合はサーバーも自分で用意したりするので、管理を AWS に任せられるので重宝しています。</p>\n<h2 id=\"サーバー構成やフォルダ構成\">サーバー構成やフォルダ構成</h2><h3 id=\"サーバー構成\">サーバー構成</h3><p>今回はこのような構成で作成します。\nLambda で Nuxt.js を動かし、API Gateway 経由で公開します。</p>\n<p><img src=\"/images/nuxtjs-on-aws-lambda/api_gw_architecture.svg\" alt=\"API Gateway 経由で Lambda にアクセスしている図\" draggable=\"false\"></p>\n<p>AWS の設定などは面倒なので、Serverless Framework でやってしまいます。\nサンプルコードでは下記コマンドで AWS の設定まで含んだデプロイが完了するようになっています。</p>\n<pre><code class=\"hljs \"><span class=\"hljs-meta\">$</span><span class=\"bash\"> yarn deploy:api_gw</span>\n</code></pre><p>※<code>serverless.yml</code> というファイルが Serverless Framework の設定ファイルになっています。\nそのファイルで Credential の設定も行っていますので、ご自身の環境に合わせていただく必要はあります。<br><code>serverless.yml</code> にもコメントを残しているので、そちらも合わせてご参照ください。</p>\n<h3 id=\"フォルダ構成\">フォルダ構成</h3><p>大まかに下記のようになっています。</p>\n<pre><code class=\"hljs \">project_root/           <span class=\"hljs-meta\"># プロジェクトのルートフォルダ</span>\n  ├ app/                   <span class=\"hljs-meta\"># フロントエンド側のソースフォルダ（Nuxt.js）</span>\n  ├ configs/             <span class=\"hljs-meta\"># 環境変数などを入れるフォルダ</span>\n  ├ <span class=\"hljs-keyword\">server</span>/               <span class=\"hljs-meta\"># \bサーバー側のソースフォルダ（Lambda）</span>\n  ├ nuxt.config.js     <span class=\"hljs-meta\"># Nuxt.js の設定ファイル</span>\n  ├ package.json      <span class=\"hljs-meta\"># npmの設定ファイル</span>\n  ├ serverless.yml    <span class=\"hljs-meta\"># Serverless Framework の設定ファイル</span>\n  └ yarn.lock              <span class=\"hljs-meta\"># npmモジュールのバージョン管理ファイル</span>\n</code></pre><p>メインのアプリケーションとなる Nuxt.js のフォルダはデプロイがしやすいように app フォルダにまとめています。</p>\n<h2 id=\"実装コードの説明\">実装コードの説明</h2><p>実装コードについては２つに分けて説明していこうと思います。\n１つはフロントエンド側（Nuxt.js）、もう１つは SSR するためのサーバー側（Node.js）です。<br>※説明しやすいようにサンプルコードとは一部異なるところもあります。</p>\n<h3 id=\"フロントエンド側_-_Nuxt.js\">フロントエンド側 - Nuxt.js</h3><p>今回は Nuxt.js のスターターテンプレートをベースに利用しています。\nほぼそのまま利用しており、<code>nuxt.config.js</code>のみ変更を加えています。</p>\n<p>変更した点は３つあり、それぞれ以下のような感じです。</p>\n<ol>\n<li>srcDirの設定</li>\n<li>Base URL の設定（base タグ設定）</li>\n<li>gzipの無効化</li>\n</ol>\n<p>1.はアプリケーションのコードを１つのフォルダにまとめる目的です。\n2.、3.は API Gateway で公開する上で必要になってきます。\nそれぞれについてもう少し深掘っていきます。</p>\n<h4 id=\"1._srcDirの設定\">1. srcDirの設定</h4><p>srcDirを設定することで１つのフォルダにまとめることができ、デプロイがやりやすくなります。\nまた、今回はサーバー側のコードもプロジェクトのフォルダに存在しているため、明確に分ける目的もあります。<br>サーバーで稼働させる時はビルド後のコードを利用するため、自分たちで書いたコードをサーバーにデプロイする必要はありません。\napp フォルダにまとまっていると Serverless Framework のパッケージング時に除外しやすくなります。<br>app フォルダにまとめる設定は簡単で、<code>nuxt.config.js</code>に<code>srcDir</code>プロパティを設定するだけでできます。</p>\n<pre><code class=\"hljs lang-JavaScript\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n  <span class=\"hljs-comment\">// 略</span>\n  srcDir: <span class=\"hljs-string\">'app'</span>,\n  <span class=\"hljs-comment\">// 略</span>\n}\n</code></pre>\n<p>srcDirについて: <a href=\"https://ja.nuxtjs.org/api/configuration-srcdir\">API: srcDir プロパティ - Nuxt.js</a></p>\n<h4 id=\"2._Base_URL_の設定（base_タグ設定）\">2. Base URL の設定（base タグ設定）</h4><p>2.に関してですが、Base URL を設定しないと JS などのリソースが取得できなくなってしまいます。\nその原因は API Gateway で生成される URL と Nuxt.js のリソースのパスの出力の仕方にあります。</p>\n<p>API Gateway で公開すると URL は下記のようになります。</p>\n<pre><code class=\"hljs \">http<span class=\"hljs-variable\">s:</span>//xxxxxxxxxx.<span class=\"hljs-keyword\">execute</span>-api.ap-northeast-<span class=\"hljs-number\">1</span>.amazonaws.<span class=\"hljs-keyword\">com</span>/dev/\n</code></pre><p>末尾についている<code>/dev/</code>のところは API Gateway のステージが入ります。\nこのステージのパスは省略ができません。\nそのため、１階層下がる前提で考える必要があります。<br>Nuxt.js では JS などのリソースのパスはルートパス（<code>/assets/app.js</code>のような書き方）で出力されます。\nこのままだと<code>https://xxxxxxxxxx.execute-api.ap-northeast-1.amazonaws.com/assets/app.js</code>を参照してしまいリソースを取得できなくなってしまいます。\nこれを解消するには Base URL を設定してあげる必要があります。<br>Base URL を設定すると head タグに </p>\n<pre><code class=\"hljs lang-HTML\">&lt;<span class=\"hljs-keyword\">base </span>href=<span class=\"hljs-string\">\"/dev/\"</span>&gt;\n</code></pre>\n<p>が追加されます。\nこれが追加されると JS のパスがルートパスで指定されていたとしても<code>https://xxxxxxxxxx.execute-api.ap-northeast-1.amazonaws.com/dev/assets/app.js</code>を参照するようになります。<br>この Base URLの設定は、router プロパティで行えます。</p>\n<pre><code class=\"hljs lang-JavaScript\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n  <span class=\"hljs-comment\">// 略</span>\n  router: {\n    base: <span class=\"hljs-string\">'/dev/'</span>\n  },\n  <span class=\"hljs-comment\">// 略</span>\n</code></pre>\n<p>baseについて: <a href=\"https://ja.nuxtjs.org/api/configuration-router#base\">API: router プロパティ - Nuxt.js</a></p>\n<h4 id=\"3._gzipの無効化\">3. gzipの無効化</h4><p>Nuxt.js はデフォルトで gzip の機能が備わっています。\nありがたい機能ではあるのですが、このままだとブラウザで表示できなくなってしまいます。（Chrome では白い画面、 Firefox では Content-Encoding に問題があると表示されます。）\n細かいところまで調べきれていないのですが、恐らく API Gateway にも gzip の機能が備わっているようです。\nそのため、2重に gzip がかかった状態になってしまい、ブラウザがデコードできないのだと推測されます。</p>\n<p>というわけで、 Nuxt.js の gzip を無効化します。\nただし、Nuxt.js のドキュメント（<a href=\"https://nuxtjs.org/api/configuration-render#gzip\">API: The render Property - Nuxt.js（英語）</a>）を見てみても無効化の仕方は書いてありません。（日本語の方は設定の仕方が古いようです。）<br>仕方ないので Nuxt.js のコードを覗いてみると Falsy な値を設定させれば無効化できそうです。（<a href=\"https://github.com/nuxt/nuxt.js/blob/dev/lib/core/renderer.js#L198\">コードはこちら</a>）</p>\n<p>gzip の無効化は render プロパティで設定できます。</p>\n<pre><code class=\"hljs lang-JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-title\">exports</span> =</span> {\n  <span class=\"hljs-comment\">// 略</span>\n  <span class=\"hljs-built_in\">render</span>: {\n    gzip: <span class=\"hljs-literal\">false</span>  <span class=\"hljs-comment\">// ドキュメントでは object になってるが false でOK</span>\n  },\n  <span class=\"hljs-comment\">// 略</span>\n</code></pre>\n<p>以上がフロントエンド側のコードです。（設定変えただけ）</p>\n<h3 id=\"サーバー側_-_Lambda\">サーバー側 - Lambda</h3><p>サーバー側は Nuxt.js を Lambda で動作させるために <a href=\"http://expressjs.com/ja/\">Express</a> を用います。\nなぜ Express かというと、 AWS Labs が Express を Lambda で動かすためのライブラリ <a href=\"https://github.com/awslabs/aws-serverless-express\">aws-serverless-express</a>を提供しているからです。\nまた、Nuxt.js のドキュメントにも Express を使った例があり、使わない手はないというところです。</p>\n<p>コードの説明に入っていく前に、Lambda でのコードの実行に関しての説明を少しだけしておきます。\nLambda はイベントがトリガーとなり実行される仕組みになっています。\nそのため、Lambda のコードはハンドラーを用意するような形になります。<br>筆者が Lambda のコードを書く場合は、ハンドラーとメインの処理が書かれたコードを分けるようにしています。\n分ける理由はローカルでメインの処理だけローカルで実行して動作確認をしたり、テストをやりやすくするためです。\n今回も同様にハンドラーである<code>hander.js</code>とメインの処理である<code>app.js</code>に分けて記述しています。\nそれぞれについて書いていきます。</p>\n<h4 id=\"hander.js_-_ハンドラー\">hander.js - ハンドラー</h4><p>ハンドラーの方は短いです。\nハンドラー関数を定義して、aws-serverless-express の proxy 関数にハンドラー関数の引数を渡しているだけです。</p>\n<pre><code class=\"hljs lang-JavaScript\"><span class=\"hljs-meta\">'use strict'</span>\n\n<span class=\"hljs-keyword\">const</span> awsServerlessExpress = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'aws-serverless-express'</span>)\n<span class=\"hljs-keyword\">const</span> { app } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./app'</span>)  <span class=\"hljs-comment\">// Express のインスタンス</span>\n\n<span class=\"hljs-keyword\">const</span> server = awsServerlessExpress.createServer(app)\n\n<span class=\"hljs-built_in\">module</span>.exports.handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event, context, callback</span>) =&gt;</span> {\n  awsServerlessExpress.proxy(server, event, context)\n}\n</code></pre>\n<h4 id=\"app.js_-_メインの処理\">app.js - メインの処理</h4><p>app.js では Express のインスタンスを生成しています。\nNuxt.js を Express で動かす場合は<code>nuxt.render</code>を使います。\n<a href=\"https://nuxtjs.org/api/nuxt-render\">API: nuxt.render(req, res) - Nuxt.js</a></p>\n<p>本来であれば Express のインスタンスに<code>nuxt.render</code>を登録するだけでよいですが、Base URL の関係で、リクエストのパスを変えてあげる必要があります。\n変えなければならない理由もまた、API Gateway です。\nAPI Gateway から Lambda に値が渡るときにステージのパスである<code>/dev/</code>が渡ってきません。\nそのため<code>nuxt.render</code>関数にに渡る前に<code>/dev/</code>を付加してあげる必要があります。</p>\n<p>※<code>dev</code>は環境変数として定義していて、<code>process.env</code>から取得させています。<br>※環境変数は<code>serverless.yml</code>で設定しています。</p>\n<pre><code class=\"hljs lang-JavaScript\"><span class=\"hljs-meta\">'use strict'</span>\n\n<span class=\"hljs-keyword\">const</span> { Nuxt } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'nuxt'</span>)\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>)\n<span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./../nuxt.config.js'</span>)\nconfig.dev = <span class=\"hljs-literal\">false</span>  <span class=\"hljs-comment\">// サーバー側で開発</span>\n\n<span class=\"hljs-keyword\">const</span> app = express()\n\n<span class=\"hljs-comment\">// Base URL の設定</span>\n<span class=\"hljs-keyword\">const</span> BASE_URL = process.env.BASE_URL\n<span class=\"hljs-keyword\">const</span> REGEXP_BASE_URL = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>(<span class=\"hljs-string\">`^<span class=\"hljs-subst\">${BASE_URL}</span>`</span>)\n<span class=\"hljs-keyword\">const</span> BASE_URL_TO_BE_ADDED = BASE_URL.replace(<span class=\"hljs-regexp\">/\\/$/</span>, <span class=\"hljs-string\">''</span>)\n<span class=\"hljs-keyword\">const</span> buildPath = <span class=\"hljs-function\">(<span class=\"hljs-params\">originalPath</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (REGEXP_BASE_URL.test(originalPath) === <span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">return</span> originalPath\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${BASE_URL_TO_BE_ADDED}</span><span class=\"hljs-subst\">${originalPath}</span>`</span>\n}\n\n<span class=\"hljs-comment\">// Nuxt.js の render 関数にもろもろ渡す</span>\n<span class=\"hljs-keyword\">const</span> nuxt = <span class=\"hljs-keyword\">new</span> Nuxt(config)\napp.use(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =&gt;</span> {\n  req.url = buildPath(req.url)\n  nuxt.render(req, res, next)\n})\n\n<span class=\"hljs-built_in\">module</span>.exports.app = app\n</code></pre>\n<h2 id=\"まとめ\">まとめ</h2><p>盛り沢山な内容になってしまいました。\n全体を通して API Gateway が問題児に見えてしまっているかもしれません。\nまあそれはそうで、API Gateway は名前の通り API を提供することが目的であり、webサーバーとして使うことに特化しているわけではありません。\n色々めんどうな手間も仕方ないことだと割り切りましょう。</p>\n<p>しかし、カスタムドメインを使うことでめんどうな手間もほぼ解消することができます。\n基本的にめんどうな手間となっていたのは、Base URL が必要だからでした。<br>Nuxt.js を Lambda で動かす上で API Gateway を経由する必要はありますが、API Gateway でもカスタムドメインを設定できますし、CloudFront を API Gateway の前に置くことでカスタムドメインを設定することもできます。\n（個人的なおすすめは CloudFront です。この話は理想の話として補足に書いています。）<br>一応サンプルではカスタムドメインを使用することも考慮して、下記コマンドを用意しています。</p>\n<pre><code class=\"hljs \"><span class=\"hljs-meta\">$</span><span class=\"bash\"> yarn deploy</span>\n</code></pre><p>このコマンドでデプロイした場合 Base URL が<code>/</code>になり、設定しなかった場合と同様になります。\nカスタムドメインを設定する前提の場合はこちらのコマンドを利用してください。</p>\n<p>一旦ここで中締めとします。\n明日は<a href=\"https://qiita.com/sunecosuri\">sunecosuri</a>さんです。\n公開されたら、この辺りにリンクを貼っておきます。</p>\n<p>下に補足として、色々書いてるのでよかったら見てください。</p>\n<h2 id=\"参考記事集\">参考記事集</h2><ul>\n<li><a href=\"https://nuxtjs.org/\">Nuxt.js - Universal Vue.js Applications</a></li>\n<li><a href=\"https://aws.amazon.com/jp/lambda/\">AWS Lambda (サーバーレスでコードを実行・自動管理) | AWS</a></li>\n<li><a href=\"https://html5experts.jp/potato4d/24346/\">Vue.js製フレームワークNuxt.jsではじめるUniversalアプリケーション開発 | HTML5Experts.jp</a></li>\n<li><a href=\"https://mya-ake.com/slides/vuejs-ssr-on-lambda\">AWS LambdaでSSRやってみた Vue.js編</a></li>\n</ul>\n<h2 id=\"補足\">補足</h2><h3 id=\"Nuxt.js_を_Lambda_で動かす際の理想の話\">Nuxt.js を Lambda で動かす際の理想の話</h3><p>先に全体像となる構成図から。</p>\n<p><img src=\"/images/nuxtjs-on-aws-lambda/ideal_architecture.svg\" alt=\"CloudFrontで分岐し、リソースはS3、HTMLはAPI Gatewayから取得する構成図\" draggable=\"false\"></p>\n<p>AWS のサービスのそれぞれの役割は下記のようになってます。</p>\n<ul>\n<li>CloudFront<ul>\n<li>キャッシュ</li>\n<li>リクエストの分岐</li>\n</ul>\n</li>\n<li>S3<ul>\n<li>静的リソースの配信</li>\n</ul>\n</li>\n<li>API Gateway<ul>\n<li>Lambda のトリガー</li>\n</ul>\n</li>\n<li>Lambda<ul>\n<li>サーバーサイドレンダリング</li>\n</ul>\n</li>\n</ul>\n<p>このように分けている理由は下記です。</p>\n<ul>\n<li>Lambda のコンピューティングリソースの最適化<ul>\n<li>JS のリクエストなどは Lambda がファイルを選択して返すだけなので、Lambda を使うまでもない（無駄なコストカット）</li>\n</ul>\n</li>\n<li>API Gateway から画像を配信する場合はめんどう<ul>\n<li>バイナリデータを扱う場合は個別に設定してあげる必要がある（サンプルでは設定してません）</li>\n</ul>\n</li>\n<li>API Gateway のキャッシュ機能は高い<ul>\n<li>なぜか時間単位で課金されてしまう</li>\n</ul>\n</li>\n</ul>\n<p>このような理由から上記のような構成図になります。<br>実際に実務でのプロジェクトでは上記のような構成になっています。</p>\n<h3 id=\"Lambda_のデプロイパッケージをなぜ小さくするのか？\">Lambda のデプロイパッケージをなぜ小さくするのか？</h3><p>これに関しては Lambda の制限が関連してきます。\n<a href=\"http://docs.aws.amazon.com/ja_jp/lambda/latest/dg/limits.html\">AWS Lambda の制限 - AWS Lambda</a>の\n「AWS Lambda デプロイメントの制限」に書かれているのですが、Lambda 関数デプロイパッケージのサイズ (圧縮 .zip/.jar ファイル)は<em>50MB</em>となっています。\n今回のサンプルのコードでも20MB弱あります。\nまた、リージョンあたりの、アップロードできるすべてのデプロイパッケージの合計サイズも75GBと制限があります。\nけっこう大きい数字に思えるかもしれませんが、Lambda をメインに使うようなマイクロサービスを構成していると割りとすぐに到達してしまうと考えられます。\nそのため、可能な限り小さくしておいた方が後々のためになります。</p>","createdAt":"2017-12-12"}