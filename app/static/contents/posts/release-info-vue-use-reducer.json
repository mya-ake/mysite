{"title":"Vue.observable() を使って Vue.js 用の React Hooks（一部）を作った","description":"","body":"<h2 id=\"なにを作ったか\">なにを作ったか</h2><p>React Hooks の<code>useReducer</code>を Vue.js 向けに作りました。</p>\n<p><a href=\"https://www.npmjs.com/package/vue-use-reducer\">https://www.npmjs.com/package/vue-use-reducer</a></p>\n<h2 id=\"なんで作ったか？\">なんで作ったか？</h2><p>最近、Vue.js × TypeScript を始めて、Vuex 周りが予想はしてたのですがツラいなーという気持ちになってました。\nすでに出ているヘルパーライブラリも見ましたが、State や Action など、それぞれデコレーターなどを書いたり個別に型定義を書く必要があるなど手間が多そうに見えました（型定義頑張りたくない）。</p>\n<p>そこで Vue.js v2.6 から使えるようになった<code>Vue.observable()</code>を使って独自の状態管理ストアを作る方針を考え始めました。</p>\n<p>※ この記事の前提</p>\n<p>個人的に Vue.js と TypeScript を使う上で次のような方針を持って開発したいと思っています。</p>\n<ul>\n<li>JavaScript のときの Vue.js とあまり書き心地が変わらない<ul>\n<li>class-style component syntax は使わない</li>\n</ul>\n</li>\n<li>型定義はあまり頑張りたくない<ul>\n<li>なるべく型推論で</li>\n</ul>\n</li>\n</ul>\n<p>という前提の上での話を書いています。</p>\n<h2 id=\"Vue.observable()\">Vue.observable()</h2><p><code>Vue.observable()</code>は Vue.js が変更検知可能な object を生成できる関数です。<br>ドキュメントはこちらです。</p>\n<p><a href=\"https://jp.vuejs.org/v2/api/index.html#Vue-observable\">https://jp.vuejs.org/v2/api/index.html#Vue-observable</a></p>\n<p>使い方はシンプルで次のとおりです。</p>\n<pre><code class=\"hljs lang-js\">import Vue <span class=\"hljs-keyword\">from</span> 'vue';\n\nconst <span class=\"hljs-keyword\">state</span> = Vue.observable({ count: <span class=\"hljs-number\">0</span> }); // 引数に object を入れる\n\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-keyword\">state</span>);   // { count: <span class=\"hljs-number\">0</span> }\n\nconst vm = new Vue({\n  template: `<span class=\"hljs-variable\">&lt;div&gt;</span>{{ count }}&lt;/div&gt;`,\n  computed: {\n    count() {\n      return <span class=\"hljs-keyword\">state</span>.count;\n    },\n  },\n  methods: {\n    increment() {\n      <span class=\"hljs-keyword\">state</span>.count++;  // こんな感じで値を変更すると表示されている template の count も変わる\n    },\n  },\n})\n\n<span class=\"hljs-keyword\">state</span>.count++;  // もちろん Vue のインスタンス外で変更しても count は変わる\n</code></pre>\n<p>ざっくり data を外に定義できるようになったと思ってもらってもいいかもしれません。\nこれができるということは自前で Vuex のようなグローバルな状態管理のストアを作れるということになります。</p>\n<p>雑に作るとこんな感じで作れます（ここから TypeScript で書きます）。</p>\n<pre><code class=\"hljs lang-ts\">import Vue <span class=\"hljs-keyword\">from</span> 'vue';\n\ntype State = { \n  count: number;\n};\n\nclass CounterStore {\n  private <span class=\"hljs-keyword\">state</span>: State;\n  constructor(initialState: State) {\n    this.<span class=\"hljs-keyword\">state</span> = Vue.observable(initialState);\n  }\n\n  get count() {\n    return this.<span class=\"hljs-keyword\">state</span>.count;\n  }\n\n  increment() {\n    this.<span class=\"hljs-keyword\">state</span>.count++;\n  }\n}\n\nexport const counterStore = new CounterStore({ count: <span class=\"hljs-number\">0</span> });\n</code></pre>\n<p>これをコンポーネントで読み込むことにより次のように使えます。</p>\n<pre><code class=\"hljs lang-ts\"><span class=\"hljs-keyword\">import</span> Vue from <span class=\"hljs-string\">'vue'</span>;\n<span class=\"hljs-keyword\">import</span> { counterStore } from <span class=\"hljs-string\">'./counterStore'</span>;\n\nexport <span class=\"hljs-keyword\">default</span> Vue.extend({\n  computed: {\n    count(): number {\n      return counterStore.count;\n    },\n  },\n\n  methods: {\n    increment() {\n      counterStore.increment();\n    },\n  },\n});\n</code></pre>\n<p>counterStore は他のコンポーネントなどでも利用でき、値は共有されることになります。\nシンプルですがグローバルな状態管理のストアを作れました。\nVuex の action のように非同期処理なども書くことができます。</p>\n<p>これでいいじゃんとも思ったのですが、やはり制約がないとなんでも書けてしまってとても Fat なストアができてしまう可能性がはらんでいます。</p>\n<p>そこで目をつけたのが React Hooks です。</p>\n<h2 id=\"React_Hooks_の_useReducer\">React Hooks の useReducer</h2><p>React Hooks についてはこの記事では深く言及はしませんが、React Hooks にはいくつかの関数が存在します。\nその中に<code>useReducer</code>という関数があります。\nreducer とあるように Redux に似ています。</p>\n<p>この<code>useReducer</code>は引数に reducer 関数と初期 state を受け取ります。\n実行すると state と state を更新するための dispatch 関数が得られます。\ndispatch 関数は Redux 同様に Action と呼ばれる object を渡して、state を更新します。</p>\n<p>見た方が早いので前述した CounterStore を useReducer を使って書きます。</p>\n<pre><code class=\"hljs lang-ts\">type State = { \n  count: number;\n};\n\ntype Action = {\n  type: 'increment';\n};\n\nconst reducer = (<span class=\"hljs-keyword\">state</span>: State, action: Action) =&gt; {\n  switch(action.type) {\n    case 'increment':\n      return {\n        ...<span class=\"hljs-keyword\">state</span>,\n        count: <span class=\"hljs-keyword\">state</span>.counter + <span class=\"hljs-number\">1</span>,\n      };\n  }\n}\n\nconst initialState: State = {\n  count: <span class=\"hljs-number\">0</span>,\n};\n\nconst [<span class=\"hljs-keyword\">state</span>, dispatch] = useReducer(reducer, initialState);\ndispath({ type: 'increment' }); // これで count が更新される\n</code></pre>\n<p>なにが嬉しいかと言うとこの仕組みだと state を更新することしかできないからです。\n（reducer で変なことやろうと思えばできるけどやるメリットがない）</p>","thumbnail":"","twitterCardType":"","createdAt":"2019-05-06"}