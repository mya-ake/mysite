# ソフトウェアエンジニアは事業を壊すかもしれないという話

@@
bosyu Advent Calendar 2019の24日目の記事です。サービスを作るエンジニアはサービスをスケールさせるための設計力が必要だぞということを書いている記事です。ほんとはwebフロントエンドの設計の記事を書く予定だったのですが、間に合わなかったので、設計の話はおまけで書いてます。
@@

==2019-12-24==

++/images/architecture/ad_20191224.png++

![](/images/architecture/ad_20191224.png)

<style>
.image-wrapper {
  max-width: 400px;
  margin: 0 auto;
}
</style>


## この記事について

こんにちはみゃけです。  
この記事は[bosyu Advent Calendar 2019](https://qiita.com/advent-calendar/2019/bosyu)の24日目の記事です。
もうアドベントカレンダーも終わりますねー。

## このタイトルで記事を書こうと思った背景

タイトルは「ソフトウェアエンジニアは事業を壊すかもしれないという話」です。
そのまんまの意味でソフトウェアエンジニア（長いのでこの記事ではエンジニアと言ってしまいます）は会社の事業を壊したり、止めたりという原因に成りかねないという話です。  
けっこう大それたタイトルなんですが、ここ数年しみじみと感じているので一度記事として書いておきたいなと思いました。

Webサービスやアプリなどを事業としているほとんどの会社にはエンジニアが在籍していて、日々そのサービスの開発をしていると思います。
満を持してサービスローンチを行い、多額の資金調達を行う会社はそれなりの数が存在します。
そこから順調に業績を伸ばし、IPO（新規上場）や事業売却をする会社も存在します。
ただそこまでいける会社は一握りです。
そこまで辿り着けない原因はいくつかあると思います。

- 顧客、ユーザーが集まらなかった
- 資金が尽きた
- 継続していくための人がいなくなった

などなどさまざまです。

これらの原因の根本的な原因もいくつかあるかもしれませんが、インターネットを通じてサービスを提供している会社の場合はエンジニアが大きく関わってきています。
サービスをローンチするというところまではそこまで難しいこともなく無事に事が進むでしょう。
問題はそこから先です。

- 継続リリースをするとバグやデグレが発生する
- 経営陣やユーザーの要望に応えるのまで時間がかかる
  - 機能追加が難しいコードになっている
- ランニングコストの増加
- セキュリティの問題

いわゆる「技術的負債」と呼ばれるものが顕在化してきます。
リリースまではなんとなく危ういなーとか思いつつもそれなりに動いているし大丈夫かみたいな力が働いて見ないようにしていたものが見えてくるみたいなやつです。

「ランニングコストの増加」や「セキュリティの問題」については最初にちゃんとコスト計算して、セキュリティリスクを把握しておくことが重要というか必須です（ここについて語るつもりも知識も十分ではないのでこれ以上書きません）。

「継続リリースをするとバグやデグレが発生する」「経営陣やユーザーの要望に応えるのまで時間がかかる」についてはサービスの作り方の問題です。
この問題が顕在化してくると事業としてアクセルを踏みたいときに踏めないみたいな状況となり好機を逃すことになるかもしれません。
また新規性で話題になっていたとしても、でかい会社に類似サービスを出され、追従されると厳しい戦いになります（そうならないために特許でガチガチにできれば優位は保てるかもしれませんが）。

このようなアクセルを踏みたくても踏めずに失速してくという話はたまに聞こえてきます。
せっかく世にサービスが出て、話題になったとしてもこれでは浮かばれません。
このような状況にしてしまう原因の一部は我々エンジニアなのです。

## 事業のブレーキとならないために

理想の話をすれば、機能の追加や改善をスムーズに行い、スムーズにリリースできることです。
スムーズなリリースについてはCI/CDの環境を作るのが一般的になってきているので、そこは自社のサービスなら用意しておきましょう。
手動でやる時代ではないです。

問題となるのは機能の追加や改善をスムーズに行えないことです。
原因は簡単で、コードがそうなっていないから。
可読性がなくスパゲッティになっていたり、コンポーネント同士が密結合になっていたり、共有されるべきスコープを越えたコードが存在していたりなどです。
要は設計に問題があり、品質が良くないコードという場合です。

この問題は[Chean Architecture](https://www.amazon.co.jp/dp/4048930656)や[エリック・エヴァンスのドメイン駆動設計](https://www.amazon.co.jp/dp/4798121967)などでも書かれているのですが、サービスは規模や時間経過とともに、機能追加や改善にかかるコストは増加傾向になります（Clean Architectrueの方に具体的なグラフとか載っている）。
ある程度コストが増加していくのは仕方のないことですが、設計によりコストの増加傾向を抑えることはできます。
つまり設計をしっかりすれば事業のブレーキにはなりづらいという話になります。

### 設計できるリードエンジニアをチームにおく

設計といっても一朝一夕で身につくようなものではありません。
前述したClean Architectureやドメイン駆動設計などの設計に関する書籍を読み、現場で実践して身につくスキルだと個人的には考えます。
また、設計のスキルを持ったエンジニアのレビューを受けることでも身につきます。

設計に自信が持てない少人数のチームであれば、リードしてくれるエンジニアを立てたり、迎える（社員や業務委託）のがよいでしょう。
そして開発初期にレビューやペアプログラミングを重点的に行いチームの底上げを行います。
そうすると初期は開発速度が出ないのですが、徐々に設計スキルなどが身につき速度とコードの品質が上がっていきます。
ローンチ後も機能追加などは行いやすい状態になっているでしょう。

### サービスの運用が始まってからのリファクタリング

よくローンチ後にリファクタリングのタイミングを設けようという話にはなるのですが、まあ実際のところそんな時間はないですよね。
週1のリファクタリングの時間を作るっていうのもいつの間にか形骸化しがちです。
これらはよくある話だと思います。  
ただ、チームとしてもなんとなくこのままじゃだめだみたいな空気感はあります。
こういうのは早めに手をうっていかないといずれやるからいいだろうみたいな割れ窓理論的に割れ窓が増えていくことにつながります。

どうするのがいいのかって話ですが、1つは当たり前ですがいつかのままにしておかないことです。
ただいきなりメンバーでいっせいにやるぜってやっても、方針が立っていないとけっこう時間をムダにしてしまいがちです。
あらかじめ、1人でもいいので方針を決めておくというのをしておくのがよいでしょう。  
また2つ目としては誰か専任でリファクタリングし続けるとういのもあります。
リファクタリングした内容の周知も含め定期的なMTGなどをしておくとチーム内に変更も浸透し全体的な品質の向上も見込めます。
またMTG内で今後の方針の再確認もしていけるとよいかもしれません。

### 新規サービスを開発するときの選択肢としてNo Codeはどうか

正直な話、当たるかどうかもわからないサービスにお金も時間もかけたくないというのが本音だと思います。
そういった需要があるので最近はプログラミング不要でサービスが作れるNo Codeに注目が集まっています。
筆者自身はまだ触ったことがない（まだ興味がそそられていないし自身に対する需要もないというのもある）ですが、プロトタイプのサービスを作るときにはもってこいだと思います。  
ただ、No Codeのサービスはスケールやパフォーマンスが使っているプラットフォームに依存してしまいます。
スケール可能でもスケールするとコストがとんとんと上がっていくことになるでしょう（サービス提供側も事業としてやってるので儲けないとやっていけない）。
また、サービスの提供が終了するかもしれません。
これは純粋にリスクですし、ずっと依存し続けるのは得策とは言えません（順調なのにサービスを停止しないといけなくなるのはほんと笑えない）。
そのためどこかで内製に切り替えるタイミングが必要でしょう（ステージで言うとアーリー〜ミドル初期ぐらいが妥当そう）。

## まとめ

最近考えていたことを書けた気がします。
今年はフリーランスになり技術顧問や業務委託でさまざまなチームを経験させてもらいました。
多くは書けないですが、どのチームも負債と戦っていたり、設計で悩んでいたりと似たような課題を持っていました。
僕が入っているうちに伝えきれればよかったのですが、1社1社にかけられる時間も限られており、どうも伝えきれていないと個人的に思っていました。
一緒に仕事した人たちにも届いてくれると嬉しいなと思います。

設計についてはほんとに作るサービスによって多様で、銀の弾丸のようなものは存在しません。
まずは先達の経験が詰まった著書を読むなどして、自分で身につけて行く必要があると思います。
また、web上にも優れた記事やサイトが存在しています。
[プログラマが知るべき97のこと](https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com)などは無料で読めて、1つ1つが長くないのでちょっとずつ読み進められるのでオススメです。  
ただ設計はかなり抽象的な話になりがちです。書籍を読むだけではわかりづらいので、実装してみた系の記事と書籍、解説記事などを往復しながら読み進めていくとよいかもしれません。
注意点があるとすれば解釈が人それぞれになったりするので、書籍（原著や翻訳版）をベースに複数の解説を見る方がよいでしょう。

記事のタイトルにもしていますが、ほんとにエンジニアは事業を壊してしまう可能性があります。
事業としてスケールすれば世界とも戦えたかもしれない事業を潰してしまうことにもなりかねないです。
そのあたりのことも考えて、我々エンジニアは事業に向き合っていく必要があると思います。
ビジネスのことはよくわからないという人も、コードをきれいに保っておくことが成功につながることもあるので、コードと真摯に向き合うことが大切かと思います。
ただ、向き合いすぎて遅くなっては本末転倒なので、そのあたりのバランス感覚も大切だと考えます。

最後にほんとは24日のアドベントカレンダーで書く予定だったwebフロントエンドの設計の話を補足的に書いておきます。
先に断っておくとここから下の部分で1記事書けそうな感じです。
暇な人は見てやってください。


## ほんとは書きたかったwebフロントエンドの設計の話

サンプルのコードを書ききれてない&DDD本読みきれてなくて中途半端な状態になったので、おまけ的に現状考えていることを書いておきます。
俺が考えた最強のアーキテクチャ的の話ですが、書きながら整理しつつブラッシュアップしたいのでお付き合いください。  
あと話の流れでVue.jsやReactが出てきてAngularが出てこないみたいになってますが、最近のAngularは追えておらず出せないだけなので悪しからず。

### 設計概要

設計の方針は「DDDっぽく、負債になりづらい程度のレイヤー分けをする」です。
捨てやすく組み込みやすいを目指します。
ターゲットは内製の新規サービスの開発時です。
設計や調査に時間をかけていられないけど、サービスは早くローンチしたいし、運用が始まってからのリリース速度もそれなりに保ちたいみたいなところです。
そしてある程度方向性が見えたらリニューアルするという選択が迫られると思うのですが、その場合に再利用がある程度できる状態を目指します。
また、DDDやClean Architectureにがっつり乗っ取るとけっこうな層や役割ができ、手数が増えるので、コストを最小限に抑えたい初期段階のサービスには向かないと個人的には考えています（ユビキタス言語の定義ぐらいはしておきたいという気持ちはある）。
なのでDDDやClean Architectureのいいところ残しつつ層や役割を少なくできないかなーっという妄想しながら考えてます。
先に断っておくと全然レイヤー多いし手数も多そうみたいなものしかまだできてないです😇
机上の空論にならないようにこの記事やコードを書いている状況です。
そのため拙い部分もあるかもしれませんが、そこは途中ということをお許しください。


サンプルコードは[RealWorld](https://github.com/gothinkster/realworld)をベースに作っています。
RealWorldはよくあるToDoアプリじゃ検証にならないよねってことで考えられたサンプルアプリケーションです（起源まで調べたわけじゃないのでテキトーなこと言ってるかもしれません）。

どんなものが作られるかは[こちら](https://vue-vuex-realworld.netlify.com)を見ていただくと良いかと思います。
こちらはVue.jsで作られたものです。
実際にユーザーを作成したりも可能になっていますが、パブリックなAPIサーバーと繋がっているので個人が特定できるようなデータは入力しないことをオススメします。

今作っているサンプルコードは[こちらのリポジトリ](https://github.com/mya-ake/vue-composition-api-realworld)です。
Vue Composition APIを使いって書きたかったので、Vue.jsで書いています。
ただviewのフレームワーク・ライブラリに依存するようなものではないので、この記事ではVue.jsについての話はほぼ出てこないです。

### 今のところ考えているレイヤー構造

5層+モジュールごとの縦割りが入る形です。
突貫で作った図を載せておきます。

<div class="image-wrapper">

![](/images/architecture/my_ddd.png)

</div>

上から下に依存（利用）する方向です。逆はありません（Domain層がUse Case層を使うみたいなやつはない）。

それぞれの層を一言ずつぐらいで紹介すると

- Repository層：APIサーバーとのHTTP通信や外部サービス、IndexedDBやインメモリのデータストアに接続するところ
- Domain層：ドメインのふるまい（ビジネスロジック、データの取得や保存、バリデーションなど）を書くところ
- Use Case層：複数のドメインの操作をしたりなど特定の処理を束ねるところ（Facadeの役割）
- UI Service層：UIやフレームワーク・ライブラリに合わせた、レンダリングに必要なデータを用意するところ（Vue.jsのscript、ReactのJSX以外のところ）
- UI層：HTMLをレンダリングするところ（Vue.jsのtemplateやReactのJSX部分）

UI層、UI Service層はviewのフレームワーク・ライブラリに依存しますが、Use Case層より下はviewのフレーム・ライブラリのAPIは使わずに素のTypeScript（または、JavaScript）で書きます。
割とよくある感じの構造なので真新しい感じではないですが、特徴としては縦にも切って、モジュールごとに管理しようという点です。

ディレクトリ構造を作るとこんな感じでしょうか（サンプルコードはまだこうなってないです）。

```
src/
　├ modules/
　│　├ user/
　│　│　├ components/
　│　│　├ services/
　│　│　└ usecases/
　│　├ article-list/
　│　└ article-detail/
　├ components/   # BaseButtonなどグローバルなやつ
　├ pages/        # ページとなるコンポーネント、モジュールのコンポーネントをレイアウトなど
　├ domains/
　└ repositories/
```

modulesの中はUse Case層、UI Service層、UI層が入ります。
Domain層、Repository層はモジュールに囚われず利用されるので、modulesには含めていません。
またコンポーネントもグローバルに利用されるもの、たとえばボタンなどはモジュールを超えて利用されるので、これもmodulesの外に出しています。
ディレクトリ構造図に書かなかったですが、他のユーティリティとかライブラリのアダプターとかもそれぞれmodulesに含めず、src直下にディレクトリを作ってしまえばよいでしょう。

### モジュール

モジュールは捨てやすく組み込みやすいを実現するための分類です。
modulesはUIパーツと思ってしまってよいです。
Twitterでいうならタイムラインやサイドバー、おすすめユーザーなどがモジュールになります。

このモジュールはUIが変わるならUI層を変えればよいですし、UIが大きく変わるとなれば新しいモジュールを作り、使えるUI Service層やUse Case層を移植し、置き換えることができたら既存のモジュールを消します。

経験してる方も多いと思いますが、既存のコードを書き換えるというのはけっこうハードルが高いです。
コードのリーディングから始まり（自分で書いていたとしても）現状を把握するところから始まります。
JS部分などは関数名から動きを予測しやすいですが、UI層となるHTML、CSS部分は余計難しいです。
UI層が変わるのであれば、既存コードを読まずに置き換えてしまえぐらいがカジュアルにできるとよいと考えます。

### コンポーネント設計

これまでAtomic Designや粒度で分類するというのをやってきていました。
そのときの話とかは[Atomic Design ベースのコンポーネント設計を考えてみた](https://mya-ake.com/posts/component-design-based-on-atomic-design/)をご覧ください（書いてみての後日譚は別のスライドとして残っています）。

粒度でやったときの課題感としては次が挙げられます。

- 決められた粒度に分類するための議論が必要
- このOrganismを構成しているコンポーネントはどれ？
- このコンポーネントは更新しても大丈夫？
- 使ってないコンポーネントは消しておきたいんだけどどれ？
- 数が多くて覚えきれない
  - カタログのようなものがないと名前と見た目が一致しなくなる

作ってる間はうまくいってる感じするのですが、開発後期や運用が始まるとこれらの課題感を実感してきます。
正直ツールによる補助がないと厳しいなと思います。依存を視覚化したり、コンポーネントを見るためのカタログなどです。
これらのツールまでメンテしないといけないとなるとかなり時間が割かれてしまいます。
アプリケーションを作っているのかツールを作っているのかわからなくなります。

じゃあどうするのかというとUIの大きなパーツで分けてしまえというところに今は落ち着いています。
前述したモジュールですね。
モジュールで分けるとデータや処理もまとまってくるので、関連しているものが集まるので触りやすいです。
このコンポーネントを変えるとあのコンポーネントが変わるかもしれないなどという心配もなくなります。
使ってる使ってないなどもモジュール内に閉じているので明確です。

モジュールを作るのはいいとしてもモジュールは1つのコンポーネントで構成するというわけにもいきません。
モジュールの中でもコンポーネント分割は生まれてきます。
これについては見通しがいい分け方ならなんでもいいと思います。
モジュールの規模感もあるかもしれませんが、Container/Presentationalコンポーネントの指針でおおよそきれいにまとまるはずです。
モジュール内のコンポーネント設計指針については作るアプリケーションの規模種類によるので、チームでざっくり方針を立てるのがよいでしょう。

もちろんボタンやユーザーアイコンなど基礎的なコンポーネントは別途用意しておく必要があると思います。
こういうのは前述の通り`/src/components/base`あたりに格納しておいて、モジュールから利用するのがよいと思います。
またモジュールによってはbaseと似てはいるけど違うんだよなーみたいなコンポーネントも出てくると思うので、そういったものはbaseのコンポーネントに拡張の余地を残しておくか、モジュール内で新しく作ればよいです。
モジュール内で新しく作る場合は、baseとなる機能に漏れないよう作っておくべきです。
ReactであればHooks、Vue 3であればCompostion APIなどいい感じに機能を分離して記述できるようになってきているので、活用することで漏れないように作れると思います。

加えてモジュール同士でコンポーネントを共有したいみたいなケースも出てくると思います。
そういったものも`/src/components/<domain-name>`みたいな感じで共有します。
ただ、こういうケースは実は同じモジュールにできるという可能性もはらんでいるので、作りたくなったら立ち止まる必要があります。

### リニューアルするときの再利用性

リニューアルする際にはDDDを基本にします。
規模感にもよるかもしれませんが、今考えているアーキテクチャより層や役割が増えると思います。
冒頭にも書いたのですが、リニューアルをする際にある程度再利用させたいです。
欲を言えば現行のものをリファクタリングして、リニューアルができればさらによいと考えています。  
ただ作るものによっては全然再利用できんやんってことも普通にありえるので、この再利用性については希望的観測が多分に含まれています。

リニューアルするとなるとデザインが大きく変わるものなので、UI層やUI Service層はほぼ捨てることになるでしょう。
これは仕方ないです。
しかし、捨てることになるので他のフレームワーク・ライブラリに乗り換えることも選択としては可能になります。
数年後には新しいものができているかもしれませんし、そのときに選択できる余地を残しておきたいです。
まあただこれまで書いてきた知見もあるので、view系のライブラリは使い続けるに越したことはないしょう。

Use Case層より下は素のTypeScriptで書かれているので再利用可能なものも出てきます（出てきてほしい）。
リニューアルしたとしてもバックエンドのDBの構造は大きく変わるものでもないので、Domain層やRepository層はそこまで変わらないので再利用できるんじゃないかなーっと楽観的に考えます。

つらつら書いてましたが、再利用性とか気にせず、保守性高く作っておけばおのずと再利用できるものになってるかもしれないので、開発しているときはあまり気にしないのがいい気がしてきました。
使い回せたらラッキーと思っていましょう。

（このセクション必要だったのだろうか、、）

### このアーキテクチャで扱えないものがでてきたら

開発してるとどうしても想定していた構造に当てはまらないものが出てきがちです（ぱっと例が出てこないですが）。
そういたったものは無理に含めず、独立して考えるのがよいです。
大事なのは依存の方向を一方向にすることです。
これさえ守っていれば大きく壊れる可能性は低いです。

### まとめ

ざっと今考えていることを書いたのですが、まだまだ荒削りだなーっと思います。
そのあたりはRealWorldのコードを書いたり別のものを作ったりしながらブラッシュアップしてけたらと思います。  
あと考えていて思うのはDDDやClean Architectureの劣化版でしかないんじゃないかというのも思ったりします。
ただそれぞれチームのメンバーに浸透させるのにはそれなりの時間がかかりますし、経験の浅いメンバーからするとなぜこんなに分けて書くの？ってなると思います。
そこをちゃんと理由を付けて解説するのが役割かもしれませんが、話したとしてもすぐに理解につながるとは思えません。
自分自身がプログラムを書き始めた頃を思い出しても、その頃は「なんかわからんけど、プログラムが動いて楽しい!よし作れた！」みたいな状態なので、設計の大事さってのは感じない気がします。  
いやまあでも、教えるのが正しいですね、しっかり解説できて納得させるぐらいの力を自分が身につければいいだけの話ですね。
逃げてはいけないところな気がしてきました。

それでもアーキテクチャを考えることはムダではないと思いますし、考えることで自分の現場に合わせられる力につながると思います。
いろいろ試行錯誤して、自分なりの解を見つけていけるようがんばりたいと思います。
とりあえずDDD本読み切ろう（Kindleで読んでるんですが、読み終えるまでの時間がなかなか減らなくていつ読み終わるんだろうと精神的にツラいお気持ちになる）。

なんかうまくまとめられませんが、みんな設計を学んで、俺が考えた最強のアーキテクチャ作っていこう！！
