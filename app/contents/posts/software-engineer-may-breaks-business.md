# ソフトウェアエンジニアは事業を壊すかもしれないという話

==2019-12-24==

## この記事について

この記事は[bosyu Advent Calendar 2019](https://qiita.com/advent-calendar/2019/bosyu)の24日目の記事です。
もうアドベントカレンダーも終わりますねー。

## このタイトルで記事を書こうと思った背景

タイトルは「ソフトウェアエンジニアは事業を壊すかもしれないという話」です。
そのまんまの意味でソフトウェアエンジニア（長いのでこの記事ではエンジニアと言ってしまいます）は会社の事業を壊したり、止めたりという原因に成りかねないという話です。  
けっこう大それたタイトルなんですが、ここ数年しみじみと感じているので一度記事として書いておきたいなと思いました。

Webサービスやアプリなどを事業としているほとんどの会社にはエンジニアが在籍していて、日々そのサービスの開発をしていると思います。
満を持してサービスローンチを行い、多額の資金調達を行う会社はそれなりの数が存在します。
そこから順調に業績を伸ばし、IPO（新規上場）や事業売却をする会社も存在します。
ただそこまでいける会社は一握りです。
そこまで辿り着けない原因はいくつかあると思います。

- 顧客、ユーザーが集まらなかった
- 資金が尽きた
- 継続していくための人がいなくなった

などなどさまざまです。

これらの原因の根本的な原因もいくつかあるかもしれませんが、インターネットを通じてサービスを提供している会社の場合はエンジニアが大きく関わってきています。
サービスをローンチするというところまではそこまで難しいこともなく無事に事が進むでしょう。
問題はそこから先です。

- 継続リリースをするとバグやデグレが発生する
- 経営陣やユーザーの要望に応えるのまで時間がかかる
  - 機能追加が難しいコードになっている
- ランニングコストの増加
- セキュリティの問題

いわゆる「技術的負債」と呼ばれるものが顕在化してきます。
リリースまではなんとなく危ういなーとか思いつつもそれなりに動いているし大丈夫かみたいな力が働いて見ないようにしていたものが見えてくるみたいなやつです。

「ランニングコストの増加」や「セキュリティの問題」については最初にちゃんとコスト計算して、セキュリティリスクを把握しておくことが重要というか必須です（ここについて語るつもりも知識も十分ではないのでこれ以上書きません）。

「継続リリースをするとバグやデグレが発生する」「経営陣やユーザーの要望に応えるのまで時間がかかる」についてはサービスの作り方の問題です。
この問題が顕在化してくると事業としてアクセルを踏みたいときに踏めないみたいな状況となり好機を逃すことになるかもしれません。
また新規性で話題になっていたとしても、でかい会社に類似サービスを出されると厳しい戦いになります（そうならないために特許でガチガチにできれば）。



[Chean Architecture](https://www.amazon.co.jp/dp/4048930656)
[エリック・エヴァンスのドメイン駆動設計](https://www.amazon.co.jp/dp/4798121967)



## 新規サービスを開発するときの戦略はどうするか

正直な話、当たるかどうかもわからないサービスにお金も時間もかけたくないというのが本音だと思います。
そういった需要があるので最近はプログラミング不要でサービスが作れるNo Codeに注目が集まっています。
筆者自身はまだ触ったことがない（まだ興味がそそられていないし自身に対する需要もないというのもある）ですが、プロトタイプのサービスを作るときにはもってこいだと思います。
ただ、No Codeのサービスはスケールやパフォーマンスが使っているプラットフォームに依存してしまいます。
スケール可能でもスケールするとコストがとんとんと上がっていくことになるでしょう（サービス提供側も事業としてやってるので儲けないとやっていけない）。
また、サービスの提供が終了するかもしれません。
これは純粋にリスクですし、ずっと依存し続けるのは得策とは言えません（順調なのにサービスを停止しないといけなくなるのはほんと笑えない）。
そのためどこかで内製に切り替えるタイミングが必要でしょう（ステージで言うとアーリー〜ミドル初期ぐらいが妥当そう）。

## ほんとは書きたかったwebフロントエンドの設計の話

サンプルのコードを書ききれてない&DDD本読みきれてなくて中途半端な状態になったので、記事の方向をちょっと?変えちゃいました。

設計の方針は「DDDっぽく、負債になりづらい程度のレイヤー分けをする」です。
捨てやすく組み込みやすいを目指します。
ターゲットは新規サービスの開発時です。
設計や調査に時間をかけていられないけど、サービスは早くローンチしたいし、運用が始まってからのリリース速度もそれなりに保ちたいみたいなところです。
そしてある程度方向性が見えたらリニューアルするというのを念頭においてます。
DDDやClean Architectureにがっつり乗っ取るとけっこうな手数になるのでコストを最小限に抑えたい初期段階のサービスには向かないと個人的には考えています。
なのでDDDやClean Architectureのいいところ残しつつ手数を少なくできないかなーっという妄想しながら考えてます。
先に断っておくと全然レイヤー多いし手数も多そうみたいなものしかまだできてないです😇
机上の空論にならないようにこの記事やコードを書いている状況です。
そのため拙い部分もあるかもしれませんが、そこは途中ということを念頭においてください。


サンプルコードは[RealWorld](https://github.com/gothinkster/realworld)をベースに作っています。
RealWorldはよくあるToDoアプリじゃ検証にならないよねってことで考えられたサンプルアプリケーションです（起源まで調べたわけじゃないのでテキトーなこと言ってるかもしれません）。

どんなものが作られるかは[こちら](https://vue-vuex-realworld.netlify.com)を見ていただくと良いかと思います。
Vue.jsで作られたものです。
実際にユーザーを作成したりも可能になっていますが、パブリックなAPIサーバーと繋がっているので個人が特定できるようなデータは入力しないことをオススメします。

### 今のところ考えているレイヤー構造

5層+モジュールごとの縦割りが入る形です。
突貫で作った図を載せておきます。

図

上から下に依存（利用）する方向です。逆はありません（Domain層がUse Case層を使うみたいなやつ）。

それぞれの層を一言ずつぐらいで紹介すると

- Repository層：APIサーバーとのHTTP通信や外部サービス、IndexedDBや独自のインメモリのデータストアに接続するところ
- Domain層：ドメインのふるまい（ビジネスロジック、データの取得や保存、バリデーションなど）を書くところ
- Use Case層：複数のドメインの操作をしたりなど特定の処理を束ねるところ（Facadeの役割）
- UI Service層：UIやフレームワーク・ライブラリに合わせた、レンダリングに必要なデータを用意するところ（Vue.jsのscript、ReactのJSX以外のところ）
- UI層：HTMLをレンダリングするところ（Vue.jsのtemplateやReactのJSX部分）

割とよくある感じの構造なので真新しい感じではないです。
特徴としては縦にも切って、モジュールごとに管理しようという点です。

ディレクトリ構造を作るとこんな感じでしょうか（サンプルコードはまだこうなってないです）。

```
src/
　├ modules/
　│　├ user/
　│　│　├ components/
　│　│　├ services/
　│　│　└ usecases/
　│　├ article-list/
　│　└ article-detail/
　├ components/   # BaseButtonなどグローバルなやつ
　├ pages/        # ページとなるコンポーネント、モジュールのコンポーネントをレイアウトなど
　├ domains/
　└ repositories/
```

modulesの中はUseCase層、UI Service層、UI層が入ります。
Domain層、Repository層はモジュールに囚われず利用されるので、modulesには含めていません。
またコンポーネントもグローバルに利用されるもの、たとえばボタンなどはモジュールを超えて利用されるので、これもmodulesの外に出してしまっています。
図に書かなかったですが、他のユーティリティとかライブラリのアダプターとかもそれぞれmodulesに含めず、src直下にディレクトリを作ってしまえばよいでしょう。

### モジュール

モジュールは捨てやすく組み込みやすいを実現するための分類です。
modulesはUIパーツと思ってしまってよいです。
Twitterでいうならタイムラインやサイドバー、おすすめユーザーなどがモジュールになります。

このモジュールはUIが変わるならUI層を変えればよいですし、UIが大きく変わるとなれば新しいモジュールを作り、使えるUI ServiceやUse Case層を移植し、置き換えることができたら既存のモジュールを消します。

既存のコードを書き換えるというのはけっこうハードルが高いです。
コードのリーディングから始まり（自分で書いていたとしても）現状を把握するところから始まります。
JS部分などは関数名から動きを予測しやすいですが、UI層となるHTML、CSS部分は難しいです。
UI層が変わるなら読まずに置き換えてしまえぐらいがカジュアルにできるとよいと考えます。

### コンポーネント設計

これまでAtomic Designや粒度で分類するというのをやってきていました。
そのときの話とかは[Atomic Design ベースのコンポーネント設計を考えてみた](https://mya-ake.com/posts/component-design-based-on-atomic-design/)をご覧ください（書いてみての後日譚は別のスライドとして残っています）。

粒度でやったときの課題感としては次が挙げられます。

- 決められた粒度に分類するための議論が必要
- このOrganismを構成しているコンポーネントはどれ？
- このコンポーネントは更新しても大丈夫？
- 使ってないコンポーネントは消しておきたいんだけどどれ？
- 数が多くて覚えきれない
  - カタログのようなものがないと名前と見た目が一致しなくなる

作ってる間はうまくいってる感じするのですが、開発後期や運用が始まるとこれらの課題感を実感してきます。
正直ツールによる補助がないと厳しいなと思います。依存を図示したり、コンポーネントを見るためのカタログなどです。
これらのツールまでメンテしないといけないとなるとかなり時間が割かれてしまいます。
アプリケーションを作っているのかツールを作っているのかわからなくなります。

じゃあどうするのかというとUIの大きなパーツで分けてしまえというところに今は落ち着いています。
前述したモジュールですね。
モジュールで分けるとデータや処理もまとまってくるので、関連しているものが集まるので触りやすいです。
このコンポーネントを変えるとあのコンポーネントが変わるかもしれないなどという心配もなくなります。
使ってる使ってないなどもモジュール内に閉じているので明確です。

モジュールを作るのはいいとしてもモジュールは1つのコンポーネントで構成するというわけにもいきません。
モジュールの中でもコンポーネント分割は生まれてきます。
これについては見通しがいい分け方ならなんでもいいと思います。
モジュールの規模感もあるかもしれませんが、Container/Presentationalコンポーネントの指針でおおよそきれいにまとまるはずです。
モジュール内のコンポーネント設計指針については作るアプリケーションの規模種類によるので、

もちろんボタンやユーザーアイコンなど基礎的なコンポーネントは別途用意しておく必要があると思います。
こういうのは前述の通り`/src/components/base`あたりに格納しておいて、モジュールから利用するのがよいと思います。
またモジュールによってはbaseと似てはいるけど違うんだよなーみたいなコンポーネントも出てくると思うので、そういったものはbaseのコンポーネントに拡張の余地を残しておくか、モジュール内で新しく作ればよいです。
モジュール内で新しく作る場合は、baseとなる機能を漏れないように作っておくべきです。
ReactであればHooks、Vue.jsであればCompostion APIなどいい感じに機能を分離して記述できるようになってきているので、活用することで漏れないように作れると思います。
